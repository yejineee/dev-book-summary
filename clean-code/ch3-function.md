# CH3. 함수

📆 2021.09.25

## 함수는 작게 만들기

> 블록과 들여쓰기

- if문, else 문, while문 등에 들어가는 블록은 **한 줄이어야 한다.**
    - 바깥을 감싸는 함수도 작아지고, 블록 안에서 호출하는 함수 이름을 적절히 지으면, 코드를 이해하기 쉬워진다.

## 함수는 한 가지 일만 처리하기

"함수는 한 가지 해야한다. 그 한 가지를 잘해야 한다. 그 한 가지만을 해야 한다."

- 함수가 한 가지만 한다고 판단하기
    - 지정된 함수 이름 아래에서 **추상화 수준이 하나인 단계만 수행**하면, 그 함수는 한 가지 작업만 한다.
    - 함수 안에서 의미 있는 이름으로 다른 함수를 추출할 수 있다면, 그 함수는 한 가지만 하는 것이 아니다.

> 함수 내 섹션

- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

## 함수 당 추상화 수준은 하나로!

- 함수 내에선 **동일한 추상화 수준** 사용하기
    - 함수가 '한 가지' 작업만 하려면, **함수 내 모든 문장의 추상화 수준이 동일**해야 한다.
- 함수 내 추상화 수준이 섞여있으면 생기는 문제점
    - 특정 표현이 근본 개념인지 세부사항인지 구분하기 어렵다.
    - 깨어진 창문처럼, 사람들이 함수에 세부사항을 점점 더 추가한다.

> 위에서 아래로 코드 읽기 : 내려가기 규칙

- **내려가기 규칙**
    - **한 함수 다음에는 추상화 수준이 한 단계 낮은 함수**가 온다.
    - 즉, 위에서 아래로 프로그램을 읽으면 **함수 추상화 수준이 한 번에 한 단계씩 낮아진다.**

## Switch 문

- switch문은 본질적으로 N가지 처리를 한다.
- **다형성(polymorphism)을 이용하여 각 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법이 있다.**
- 예시에서 지적한 문제점
    1. 함수가 길다.
    2. 한 가지 작업만 수행하지 않는다.
    3. SRP를 위반한다.
    4. OCP를 위반한다.
- 문제를 해결한 코드 : switch문을  추상팩토리 Abstract Factory에 숨긴다.

## 서술적인 이름을 사용하라

"코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면, 깨끗한 코드라 불러도 되겠다."

- 작고 단순한 함수 → 서술적인 이름을 짓기 더 쉬워짐
- 서술적인 이름 > 어려운 이름이나 서술적인 주석
    - 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
    - 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 서술적인 이름 → 코드 개선이 더 쉬워짐
    - 서술적인 이름을 사용하면, 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
- **일관성** 있는 이름 사용하기
    - 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용해야 한다.

    ```
    - includeSetupAndTeardownPages
    - includeSetupPages
    - includeSuiteSetupPage
    - includeSetupPage
    ```

## 함수 인수

- 함수의 인수 갯수는 적은게 좋고, 3개 이상은 가능한 피하자
    - 인수는 개념을 이해하기 어렵게 만든다.

        코드를 읽는 사람이 인수를 발견할 때마다 그 의미를 해석해야 한다.

    - 테스트 관점에서 인수는 더 어렵다.

        인수 조합을 따져서 함수를 검증하는 테스트케이스를 만들어야하기 때문이다. 

> 단항 인수

- 함수에 인수를 넘기는 경우
    1. 인수에 질문을 던지는 경우

        ```java
        boolean fileExists("file");
        ```

    2. 인수로 뭔가를 변환하여 결과를 반환하는 경우  

        ```java
        InputStream fileOpen("file")
        ```

        - 입력 인수를 변환하는 함수는 **변환 결과를 반환값으로 돌려주어야**한다.

            ```java
            // Bad : 출력인수 사용
            void transform(StringBuffer out)
            // Good : 입력인수 사용
            StringBuffer transform(StringBuffer in)
            ```

> 플래그 인수

- 함수로 bool값을 넘기는 것은 함수가 한꺼번에 여러 가지 일을 처리한다는 것을 의미하므로 좋지 않다.
- 인자로 bool값을 넘기기 보다는, 함수를 역할에 맞춰 나누자

> 이항 함수

인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 

```java
assertEquals(expected, actual)
```

assetEquals 함수는 expected 다음에 actual이 온다는 순서를 인위적으로 기억해야 한다. 

여기서 실수가 생길 수 있다는 위험을 이해하고, 가능하면 단항 함수로 바꾸어야 한다.

> 삼항 함수

삼항 함수는 이항 함수보다 훨씬 더 이해하기 어렵다.

> 인수 객체

- 인수가 2-3개 필요하다면, 일부를 **클래스 변수**로 선언해서 인수로 넘기자.
    - 변수로 묶어 넘기면 이름을 표현해야하므로 결국 개념을 표현하게 된다.

```java
// Bad
Circle makeCircle(double x, double y, double radius);
// Good - Point 클래스 변수로 넘기기
Circle makeCircle(Point center, double radius);
```

> 동사와 키워드

- 단항 함수는 함수와 인수가 **동사/명사 쌍**을 이루도록 하기

    ```java
    // Good
    write(name)
    // Better
    writeField(name)
    ```

- 함수 이름에 **인수 이름**을 넣는 형식

    ```java
    asserEquals(expected, actual)
    // Good : 인수 순서를 기억하지 않아도 된다.
    assertExpectedEqualsActual(expected, actual)
    ```

## 부수효과를 일으키지 마라!

- 부수효과는 거짓말이다.
    - 함수 이름에서 수행하겠다고 한 일 외에 다른 일을 하는 것이다.

        ```java
        checkPassword(String userName, String password)
        ```

        checkPassword 함수에서 암호를 확인하는 일 외에, 세션을 초기화하는 일을 하는 것은 부수효과이다. 

        이는 시간적인 결합을 초래한다. 

        즉, 세션을 초기화해도 되는 경우에만 호출이 가능해진다. 

        이러한 부수효과는 함수 내에 가려져있으므로, 혼란을 일으키게 된다.

    - 부수효과는 **시간적인 결합(temporal coupling)**이나 **순서 종속성(order dependency)을 초래한다.**
- 시간적인 결합이 필요하다면, 함수 이름에 명시할 것

    ```java
    checkPasswordAndInitializeSession()
    ```

> 출력 인수

- 출력 인수는 피하라
    - 함수에서 상태를 변경해야 한다면, 함수가 속한 객체 상태를 변경하는 방식을 택하라
- 함수 선언부를 찾아보게 되는 코드는 피하라

    ```java
    appendFooter(s)
    ```

    인수 s가 출력 인수인지, 입력 인수인지는 함수 선언부를 찾아봐야 알 수 있다.

    ```java
    public void appendFooter(StringBuffer report)
    ```

    s가 출력인수라는 것을 선언부를 보고 알 수 있다.

    함수 선언부를 찾아보는 것은 코드를 보다가 주춤하게 되는 것이다. 

    이는 인지적으로 거슬린다는 것이므로 피해야 한다. 

## 명령과 조회를 분리하라!

- 함수는 뭔가를 **수행**하거나, 뭔가에 **답하거나** 둘 중 하나이다.
- 객체 상태를 **변경**하거나, 객체 정보를 **반환**하거나 둘 중 하나이다.

```java
// Bad - 의미가 모호함
if(set("username", "bob")){
	...
}

// Good - 명령과 조회를 분리하여 모호함을 없앰
if(attributeExists("username"){ // 조회
	setAttribute("username", "bob"); // 명령
	...
}
```

## 오류 코드보다 예외를 사용하라

- 오류 코드를 반환하면, 오류코드를 곧바로 처리해야하는 문제가 생긴다.

    ```java
    if(deletePage(page) == E_OK){
    	if(registry.deleteReference(page.name) == E_OK){
    		...
    	} else {
    		logger.log("deleteReference from registry failed");
    	}
    } else {
    	logger.log("delete fail");
    	return E_ERROR;
    }
    ```

- 오류코드 대신 **예외**를 사용해서, **오류 처리 코드를 원래 코드에서 분리**하자

    ```java
    try {
    	deletePage(page);
    	registry.deleteReference(page.name);
    	configKeys.deleteKey(page.name.makeKey());
    } catch (Exception e){
    	logger.log(e.getMessage();
    }		
    ```

> Try / Catch 블록 뽑아내기

- try / catch 블록을 별도 함수로 뽑아내자
    - 정상동작과 오류 처리 동작을 분리하면, 코드를 이해하고 수정하기 쉬워진다.

```java
public void delete(Page page){
	try{
		deletePageAndAllReferences(page)'
	} catch (Exception e) {
		logError(e);
	}
}
```

> 오류 처리도 한 가지 작업이다

- 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

## 반복하지 마라! (DRY 원칙)

- DRY : Don't Repeat Yourself
- 중복은 소프트웨어에서 악의 근원이다.
    - 코드 길이가 늘어난다.
    - 알고리즘이 변하면, 중복되는 코드를 다 손봐야 한다.
    - 한 곳이라도 빠뜨리면, 오류가 발생한다.

## 구조적 프로그래밍

- **Single Entry-Exit Rule**
    - 모든 함수와 함수내 모든 블록에 입구와 출구가 하나만 존재해야 한다.
    - 함수는 return 문이 하나여야 한다.
    - 루프 안에서 break나 continue를 사용해서느 안된다.
    - goto는 절대 안된다.
- 함수를 작게 만든다면, return, break, continue를 여러차례 사용해도 괜찮다.

## 함수를 어떻게 짜죠?

1. 처음에는 길고 복잡하게 짠다.
2. 모든 코드를 빠짐없이 테스트하는 단위테스트를 만든다.
3. 리팩토링한다. 
4. 테스트에 통과하는지 확인한다. 

# 느낀점

- 함수는 한 가지 일만 하게 하기
    - 무지성으로 함수안에 모든 코드를 넣고 있었는데, 함수는 작게작게 만들어야하는구나
    - "코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면, 깨끗한 코드라 불러도 되겠다." → 이 글이 너무 와닿는다.
- 함수당 추상화 수준은 하나로
    - 추상화 수준을 의도적으로 맞춘다면, 굉장히 여러 함수가 나오게 될 것 같다. 그 함수들을 어디에 배치해야하는지도 고민이다. 컴포넌트가 있는 코드에는 높은 추상화 수준의 코드만 두는 것이 좋을까?
- 함수형 프로그래밍에서는 어떻게 인수의 갯수를 줄일 수 있을까?
    - 클린코드에서는 인수를 많이 넣는 것을 피하라고 하였다. 함수형 프로그래밍에서는 함수 내에서 필요한 데이터를 인수로 다 넘겨주어야할 것 같은데, 인수를 줄이라는 조언을 어떻게 따를 수 있을까? 커링..?
- Single entry-exit rule
    - 린트 룰 중에서 no-continue가 있는데, 왜 continue를 넣지 않는게 좋은지 궁금했었다. 오히려 continue를 넣어서, 빠르게 예외 처리를 할 수 있다고 생각했다. single entry-exit 룰은 함수에서 부수효과를 만들지 않아야하는 것처럼, 예상하지 못한 곳에서 리턴이나 제어권을 넘기는 일을 하지 말라는 것으로 이해하면 될까?
- 사이드이펙트 만들지 않기
    - 어디서나 강조하는 사이드이펙트 만들지 않기.
- 테스트코드 만들고, 리팩토링하기
    - 기능 구현을 달리다보면, 테스트를 하지 않게 된다. 테스트코드 없이 리팩토링을 하면, 혹시 기능이 제대로 동작하지 않을까 무서워진다. 그렇게 퀄리티 낮은 코드들이 생겨나는거겠지..?
